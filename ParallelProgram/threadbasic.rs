/*
threads basic
입력을 별도의 thread로 돌려 입력을 기다리는동안 프로그램이 멈추는 것을 방지한다거나
파일을 받는 동안 프로그램이 멈추는 것을 막는 등의 효과...


 */

use std::thread;
use std::time::Duration;
//주 스레드의 것은 항상 모두 실행되나
//별도의 스레드에서 실행된 것은 주 스레드가 끝나는 그 순간 모두 사라지게 됨
//그러면 실행할 때마다 별도의 스레드에서 실행된 것이 중간에 끊겨 실행할 때마다 실행되는 줄의 갯수가 달라질 수도 있음...
//그리고 병렬로 실행할 경우 병렬로 실행되는 것의 순서는 우리가 알 수 없음 : 컴퓨터 내부적으로 처리되므로...
fn main(){
    println!("동시 실행 시작");
    let t = thread::spawn(||{
        println!("첫 번째가 다른 스레드에서 실행됨");
        println!("두 번째가 다른 스레드에서 실행됨");
        println!("세 번째가 다른 스레드에서 실행됨");
        println!("네 번째가 다른 스레드에서 실행됨");
        println!("다섯 번째가 다른 스레드에서 실행됨");
    });
    //join함수를 통해 main스레드가 해당 스레드가 실행되고 나서 완료되었을 때 main스레드를 실행시키게 할 수 있음 : 별도의 스레드가 모두 처리될 때까지 기다리게 됨...
    //t.join();
    //시간으로 딜레이를 두어 별도의 스레드의 내용이 실행될 수 있도록 유예 시간을 줄 수도 있음 : 다만 주 스레드가 멈추고 기다리게 되므로 사용자는 프로그램이 멈췄다고 느낄 수 있음 + 주어진 시간이 애매할 경우 중간에 끊길 수도 있으므로

    thread::sleep(Duration::from_millis(1));


    println!("첫 번째가 주 스레드에서 실행됨");
    println!("두 번째가 주 스레드에서 실행됨");
    println!("세 번째가 주 스레드에서 실행됨");
    println!("네 번째가 주 스레드에서 실행됨");
    println!("다섯 번째가 주 스레드에서 실행됨");
    //아래의 경우처럼 하게 될 경우 주 스레드가 모두 처리되고 나서 별도의 스레드에서 처리된 것이 완료될 때까지 기다렸다가 종료하게 됨...
    t.join();

}